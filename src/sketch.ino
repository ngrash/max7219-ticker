#include "LedControl.h"
#include <avr/pgmspace.h>

#define PADDING             9
#define MSG_BUFFER_LENGTH 256
#define FRAME_DELAY        50

#define BAUD_RATE      9600
#define SERIAL_TIMEOUT 1000

#define DATA_PIN    12
#define CLOCK_PIN   11
#define SELECT_PIN  10
#define NUM_DEVICES  1

const byte font[][6] PROGMEM = {
  {1, 0x00},                         // (space)
  {1, 0xfa},                         // !
  {3, 0xe0, 0x00, 0xe0},             // "
  {5, 0x28, 0xfe, 0x28, 0xfe, 0x28}, // #
  {5, 0x24, 0x54, 0xfe, 0x54, 0x48}, // $
  {5, 0xc4, 0xc8, 0x10, 0x26, 0x46}, // %
  {5, 0x6c, 0x92, 0xaa, 0x44, 0x0a}, // &
  {2, 0xa0, 0xc0},                   // '
  {3, 0x38, 0x44, 0x82},             // (
  {3, 0x82, 0x44, 0x38},             // )
  {5, 0x10, 0x54, 0x38, 0x54, 0x10}, // *
  {5, 0x10, 0x10, 0x7c, 0x10, 0x10}, // +
  {2, 0x0a, 0x0c},                   //
  {5, 0x10, 0x10, 0x10, 0x10, 0x10}, // -
  {2, 0x06, 0x06},                   // .
  {5, 0x04, 0x08, 0x10, 0x20, 0x40}, // /
  {5, 0x7c, 0x8a, 0x92, 0xa2, 0x7c}, // 0
  {3, 0x42, 0xfe, 0x02},             // 1
  {5, 0x42, 0x86, 0x8a, 0x92, 0x62}, // 2
  {5, 0x84, 0x82, 0xa2, 0xd2, 0x8c}, // 3
  {5, 0x18, 0x28, 0x48, 0xfe, 0x08}, // 4
  {5, 0xe4, 0xa2, 0xa2, 0xa2, 0x9c}, // 5
  {5, 0x3c, 0x52, 0x92, 0x92, 0x0c}, // 6
  {5, 0x80, 0x8e, 0x90, 0xa0, 0xc0}, // 7
  {5, 0x6c, 0x92, 0x92, 0x92, 0x6c}, // 8
  {5, 0x60, 0x92, 0x92, 0x94, 0x78}, // 9
  {2, 0x6c, 0x6c},                   // :
  {2, 0x6a, 0x6c},                   // ;
  {4, 0x10, 0x28, 0x44, 0x82},       // <
  {5, 0x28, 0x28, 0x28, 0x28, 0x28}, // =
  {4, 0x82, 0x44, 0x28, 0x10},       // >
  {5, 0x40, 0x80, 0x8a, 0x90, 0x60}, // ?
  {5, 0x4c, 0x92, 0x9e, 0x82, 0x7c}, // @
  {5, 0x7e, 0x88, 0x88, 0x88, 0x7e}, // A
  {5, 0xfe, 0x92, 0x92, 0x92, 0x6c}, // B
  {5, 0x7c, 0x82, 0x82, 0x82, 0x44}, // C
  {5, 0xfe, 0x82, 0x82, 0x44, 0x38}, // D
  {5, 0xfe, 0x92, 0x92, 0x92, 0x82}, // E
  {5, 0xfe, 0x90, 0x90, 0x80, 0x80}, // F
  {5, 0x7c, 0x82, 0x82, 0x8a, 0x4c}, // G
  {5, 0xfe, 0x10, 0x10, 0x10, 0xfe}, // H
  {3, 0x82, 0xfe, 0x82},             // I
  {5, 0x04, 0x02, 0x82, 0xfc, 0x80}, // J
  {5, 0xfe, 0x10, 0x28, 0x44, 0x82}, // K
  {5, 0xfe, 0x02, 0x02, 0x02, 0x02}, // L
  {5, 0xfe, 0x40, 0x20, 0x40, 0xfe}, // M
  {5, 0xfe, 0x20, 0x10, 0x08, 0xfe}, // N
  {5, 0x7c, 0x82, 0x82, 0x82, 0x7c}, // O
  {5, 0xfe, 0x90, 0x90, 0x90, 0x60}, // P
  {5, 0x7c, 0x82, 0x8a, 0x84, 0x7a}, // Q
  {5, 0xfe, 0x90, 0x98, 0x94, 0x62}, // R
  {5, 0x62, 0x92, 0x92, 0x92, 0x8c}, // S
  {5, 0x80, 0x80, 0xfe, 0x80, 0x80}, // T
  {5, 0xfc, 0x02, 0x02, 0x02, 0xfc}, // U
  {5, 0xf8, 0x04, 0x02, 0x04, 0xf8}, // V
  {5, 0xfe, 0x04, 0x18, 0x04, 0xfe}, // W
  {5, 0xc6, 0x28, 0x10, 0x28, 0xc6}, // X
  {5, 0xc0, 0x20, 0x1e, 0x20, 0xc0}, // Y
  {5, 0x86, 0x8a, 0x92, 0xa2, 0xc2}, // Z
  {3, 0xfe, 0x82, 0x82},             // [
  {5, 0x40, 0x20, 0x10, 0x08, 0x04}, // "\"
  {4, 0x82, 0x82, 0xfe, 0x00},       // ]
  {5, 0x20, 0x40, 0x80, 0x40, 0x20}, // ^
  {5, 0x02, 0x02, 0x02, 0x02, 0x02}, // _
  {3, 0x80, 0x40, 0x20},             // `
  {5, 0x04, 0x2a, 0x2a, 0x2a, 0x1e}, // a
  {5, 0xfe, 0x12, 0x22, 0x22, 0x1c}, // b
  {5, 0x1c, 0x22, 0x22, 0x22, 0x04}, // c
  {5, 0x1c, 0x22, 0x22, 0x12, 0xfe}, // d
  {5, 0x1c, 0x2a, 0x2a, 0x2a, 0x18}, // e
  {5, 0x10, 0x7e, 0x90, 0x80, 0x40}, // f
  {5, 0x10, 0x28, 0x2a, 0x2a, 0x3c}, // g
  {5, 0xfe, 0x10, 0x20, 0x20, 0x1e}, // h
  {3, 0x22, 0xbe, 0x02},             // i
  {4, 0x04, 0x02, 0x22, 0xbc},       // j
  {4, 0xfe, 0x08, 0x14, 0x22},       // k
  {3, 0x82, 0xfe, 0x02},             // l
  {5, 0x3e, 0x20, 0x18, 0x20, 0x1e}, // m
  {5, 0x3e, 0x10, 0x20, 0x20, 0x1e}, // n
  {5, 0x1c, 0x22, 0x22, 0x22, 0x1c}, // o
  {5, 0x3e, 0x28, 0x28, 0x28, 0x10}, // p
  {5, 0x10, 0x28, 0x28, 0x18, 0x3e}, // q
  {5, 0x3e, 0x10, 0x20, 0x20, 0x10}, // r
  {5, 0x12, 0x2a, 0x2a, 0x2a, 0x04}, // s
  {5, 0x20, 0xfc, 0x22, 0x02, 0x04}, // t
  {5, 0x3c, 0x02, 0x02, 0x04, 0x3e}, // u
  {5, 0x38, 0x04, 0x02, 0x04, 0x38}, // v
  {5, 0x3c, 0x02, 0x0c, 0x02, 0x3c}, // w
  {5, 0x22, 0x14, 0x08, 0x14, 0x22}, // x
  {5, 0x30, 0x0a, 0x0a, 0x0a, 0x3c}, // y
  {5, 0x22, 0x26, 0x2a, 0x32, 0x22}, // z
  {3, 0x10, 0x6c, 0x82},             // {
  {1, 0xfe},                         // |
  {3, 0x82, 0x6c, 0x10},             // }
};

LedControl lc = LedControl(DATA_PIN, CLOCK_PIN, SELECT_PIN, NUM_DEVICES);
byte* columnsBuffer;
int columnsBufferSize;
char messageBuffer[MSG_BUFFER_LENGTH];

void setup() {
  lc.shutdown(0, false);
  lc.setIntensity(0, 1);
  lc.clearDisplay(0);

  Serial.begin(BAUD_RATE);
  Serial.setTimeout(SERIAL_TIMEOUT);

  buildColumnsBuffer("works for me");
}

void loop() {
  brotocol();
  drawFrames(columnsBuffer, columnsBufferSize);
}

void brotocol() {
  if(Serial.available() > 0) {
    char hello[3];
    byte bytesRead = Serial.readBytes(hello, 2);
    hello[2] = '\0';

    if(strcmp(hello, "hi") == 0) {
      Serial.println("sup?");
      buildColumnsBuffer("...");
      while(!Serial.available()) { drawFrames(columnsBuffer, columnsBufferSize); }

      readMsg(messageBuffer, MSG_BUFFER_LENGTH);
      buildColumnsBuffer(messageBuffer);
    }
  }
}

void readMsg(char* buffer, int length) {
  byte bytesRead = Serial.readBytesUntil('\0', buffer, length-1);
  buffer[bytesRead] = '\0';
}

void buildColumnsBuffer(char* msg) {
  destroyColumnsBuffer();

  columnsBufferSize = calculateColumnCount(msg) + PADDING*2;
  columnsBuffer = (byte*)malloc(columnsBufferSize);
  fillColumnsBuffer(msg, columnsBuffer);
}

void destroyColumnsBuffer() {
  if(columnsBuffer == 0) {
    free(columnsBuffer);
    columnsBuffer = 0;
    columnsBufferSize = 0;
  }
}

int calculateColumnCount(const char* msg) {
  int count = 0;
  char ch;
  for(int i = 0; (ch = msg[i]) != 0; i++) {
    int index = getCharIndex(ch);
    count += getCharColumnCount(index);
    count += 1; // one blank col after each char
  }

  return count;
}

void fillColumnsBuffer(char* message, byte* buffer) {
  for(int i = 0; i < PADDING; i++) {
    buffer[i] = 0;
  }

  int totalColumnIdx = PADDING;
  while(*message) {
    char ch = *message++;
    int index = getCharIndex(ch);
    int columnCount = getCharColumnCount(index);

    for(int columnIdx = 0; columnIdx < columnCount; columnIdx++) {
      buffer[totalColumnIdx++] = getCharColumnData(index, columnIdx);
    }

    buffer[totalColumnIdx++] = '\0';
  }

  for(int i = 0; i < PADDING; i++) {
    buffer[totalColumnIdx+i] = 0;
  }
}

int getCharIndex(char ch) {
  return (int)(ch - 32);
}

int getCharColumnCount(int position) {
  return pgm_read_byte(&(font[position][0]));
}

byte getCharColumnData(int position, int columnIdx) {
  return pgm_read_byte(&(font[position][1+columnIdx]));
}

void drawFrames(byte* buffer, int bufferSize) {
  for(int i = 0; i < bufferSize-8; i++) {
    drawFrame(i, buffer, bufferSize);
    delay(FRAME_DELAY);
  }
}

void drawFrame(int frame, byte* buffer, int bufferSize) {
  for(int i = 0; i < 8; i++) {
    byte col = buffer[frame + i];
    lc.setColumn(0, i, col);
  }
}
